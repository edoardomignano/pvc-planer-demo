<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PVC-Welt – Planer Demo (Pool/Bewässerung)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121a23; --text:#e8eef6; --muted:#9fb0c3; }
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin:0; background:var(--bg); color:var(--text); }
    header { padding:14px 16px; border-bottom:1px solid #1f2a36; display:flex; gap:10px; align-items:center; }
    header b { letter-spacing:.2px; }
    .wrap { display:grid; grid-template-columns: 360px 1fr; gap:12px; padding:12px; }
    .panel { background:#121a23; border:1px solid #1f2a36; border-radius:14px; overflow:hidden; }
    .panel h3 { margin:0; padding:12px 12px 10px; border-bottom:1px solid #1f2a36; font-size:14px; color:var(--muted); }
    .panel .content { padding:12px; }
    .btnrow { display:flex; flex-wrap:wrap; gap:8px; }
    button {
      background:#192434; border:1px solid #2a3a50; color:var(--text);
      padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px;
    }
    button.active { outline:2px solid #5aa7ff; }
    button:hover { filter:brightness(1.07); }
    .hint { color:var(--muted); font-size:12px; line-height:1.35; margin:10px 0 0; }
    .kv { display:grid; grid-template-columns: 1fr auto; gap:6px 10px; font-size:13px; }
    .kv div { padding:4px 0; border-bottom:1px dashed #243245; }
    .kv div:nth-last-child(-n+2) { border-bottom:0; }
    .small { color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35; }
    canvas { width:100%; height: calc(100vh - 76px); display:block; background:#0b0f14; cursor: crosshair; }
    input[type="number"], input[type="file"]{
      width:100%; padding:8px 10px; border-radius:10px; border:1px solid #2a3a50;
      background:#0f1722; color:var(--text);
    }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2a3a50; background:#0f1722; color:var(--muted); font-size:12px; }
    .section { margin-top:14px; padding-top:12px; border-top:1px solid #1f2a36; }
  </style>
</head>
<body>
<header>
  <b>PVC-Welt Planer – Demo</b>
  <span class="pill">Pool / Bewässerung • 1-Datei Demo</span>
</header>

<div class="wrap">
  <div class="panel">
    <h3>Werkzeuge</h3>
    <div class="content">
      <div class="btnrow">
        <button id="toolPool">Pool/Ziel platzieren</button>
        <button id="toolSource">Wasserquelle setzen</button>
        <button id="toolPipe" class="active">Leitung zeichnen</button>
        <button id="toolBlock">Sperrzone zeichnen</button>
        <button id="toolMove">Verschieben</button>
        <button id="toolCal">Maßstab kalibrieren</button>
      </div>

      <p class="hint">
        <b>Leitung:</b> Klicke Punkte, <b>Doppelklick</b> beendet. <b>ENTER</b> = fertig, <b>ESC</b> = abbrechen.<br>
        <b>Wichtig:</b> Die Linie folgt nur innerhalb der Zeichenfläche (Canvas). Im Menü „klebt“ nichts mehr.
      </p>

      <div class="btnrow" style="margin-top:10px;">
        <button id="btnFinish">Leitung fertig</button>
        <button id="btnCancel">Leitung abbrechen</button>
        <button id="btnClear">Alles löschen</button>
      </div>

      <div class="section">
        <div class="split">
          <div>
            <label>Skalierung (Meter pro Rasterfeld) – falls NICHT kalibriert</label>
            <input id="scale" type="number" min="0.1" step="0.1" value="0.5">
          </div>
          <div>
            <label>Rohr-Ø (nur Demo)</label>
            <input id="diam" type="number" min="16" step="1" value="50">
          </div>
        </div>

        <div style="height:12px"></div>
        <label>Hintergrundbild (Luftaufnahme / Skizze)</label>
        <input id="bgFile" type="file" accept="image/*" />

        <div class="btnrow" style="margin-top:10px;">
          <button id="btnFitBg">Bild einpassen</button>
          <button id="btnClearBg">Bild entfernen</button>
        </div>

        <p class="hint">
          <b>Bild bewegen/zoomen:</b><br>
          - Tool <b>Verschieben</b> wählen → auf leere Fläche klicken & ziehen = Bild verschieben<br>
          - Mausrad = Bild zoomen (wenn ein Hintergrundbild geladen ist)
        </p>

        <p class="hint">
          <b>Kalibrieren (maßgetreu):</b><br>
          Tool <b>Maßstab kalibrieren</b> → 2 Punkte klicken (bekannte Strecke) → Meter eingeben.<br>
          Danach werden Leitungslängen real berechnet.
        </p>
      </div>

      <div class="section">
        <h3 style="margin:0; padding:0 0 8px; border:0; color:var(--muted);">Stückliste (auto)</h3>
        <div class="kv" id="bom"></div>
        <div class="small" id="warnings"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <canvas id="c"></canvas>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ===== HiDPI Resize =====
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', resize);

  // ===== Tools =====
  const tools = {
    PIPE: 'pipe',
    POOL: 'pool',
    SOURCE: 'source',
    BLOCK: 'block',
    MOVE: 'move',
    CAL: 'cal',
  };
  let tool = tools.PIPE;

  const buttons = {
    toolPipe: document.getElementById('toolPipe'),
    toolPool: document.getElementById('toolPool'),
    toolSource: document.getElementById('toolSource'),
    toolBlock: document.getElementById('toolBlock'),
    toolMove: document.getElementById('toolMove'),
    toolCal: document.getElementById('toolCal'),
  };

  function setTool(t) {
    tool = t;
    Object.values(buttons).forEach(b => b.classList.remove('active'));
    const map = {
      [tools.PIPE]: buttons.toolPipe,
      [tools.POOL]: buttons.toolPool,
      [tools.SOURCE]: buttons.toolSource,
      [tools.BLOCK]: buttons.toolBlock,
      [tools.MOVE]: buttons.toolMove,
      [tools.CAL]: buttons.toolCal,
    };
    map[t].classList.add('active');

    // Wichtig: Wenn man Tool wechselt, Pipe-Vorschau löschen (damit nichts "klebt")
    if (state.drawingPipe) delete state.drawingPipe.preview;

    canvas.style.cursor = (t === tools.MOVE) ? 'grab' : 'crosshair';
    draw();
  }

  buttons.toolPipe.onclick = () => setTool(tools.PIPE);
  buttons.toolPool.onclick = () => setTool(tools.POOL);
  buttons.toolSource.onclick = () => setTool(tools.SOURCE);
  buttons.toolBlock.onclick = () => setTool(tools.BLOCK);
  buttons.toolMove.onclick = () => setTool(tools.MOVE);
  buttons.toolCal.onclick = () => {
    setTool(tools.CAL);
    state.cal.active = true;
    state.cal.p1 = null;
    state.cal.p2 = null;
    alert("Kalibrierung: Bitte 2 Punkte klicken (bekannte Strecke), danach Meter eingeben.");
  };

  // ===== State =====
  const state = {
    grid: 32, // px
    pool: null,       // {x,y,w,h}
    source: null,     // {x,y}
    blocks: [],       // {x,y,w,h}
    pipes: [],        // [{pts:[{x,y},...]}]
    drawingPipe: null,// {pts:[...], preview?}
    drawingBlock: null,// {x0,y0,x1,y1}
    dragging: null,    // {type, ref, ox, oy}
    draggingBg: null,  // {ox, oy, startX, startY}
    mouseInCanvas: false,

    bg: { img: null, x: 0, y: 0, scale: 1 },
    cal: { active: false, p1: null, p2: null, pxPerMeter: null },
  };

  const scaleInput = document.getElementById('scale');
  const diamInput = document.getElementById('diam');
  const bomEl = document.getElementById('bom');
  const warnEl = document.getElementById('warnings');

  function snap(v) {
    const g = state.grid;
    return Math.round(v / g) * g;
  }

  function toRect(x0,y0,x1,y1){
    const x = Math.min(x0,x1), y = Math.min(y0,y1);
    return { x, y, w: Math.abs(x1-x0), h: Math.abs(y1-y0) };
  }
  function insideRect(p, r){
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
  }

  function hitTestObjects(p){
    if (state.pool && insideRect(p, state.pool)) return {type:'pool', ref:state.pool};
    for (const b of state.blocks){
      if (insideRect(p, b)) return {type:'block', ref:b};
    }
    if (state.source){
      const dx = p.x - state.source.x, dy = p.y - state.source.y;
      if (Math.hypot(dx,dy) < 10) return {type:'source', ref:state.source};
    }
    return null;
  }

  function getPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  // ===== Background helpers =====
  function fitBackground(){
    if (!state.bg.img) return;
    const rect = canvas.getBoundingClientRect();
    const img = state.bg.img;
    const sx = rect.width / img.width;
    const sy = rect.height / img.height;
    const s = Math.min(sx, sy);
    state.bg.scale = s;
    state.bg.x = (rect.width - img.width * s) / 2;
    state.bg.y = (rect.height - img.height * s) / 2;
  }

  // ===== File upload =====
  const bgFile = document.getElementById('bgFile');
  bgFile.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      state.bg.img = img;
      fitBackground();
      draw();
    };
    img.src = URL.createObjectURL(file);
  });

  document.getElementById('btnFitBg').onclick = () => { fitBackground(); draw(); };
  document.getElementById('btnClearBg').onclick = () => {
    state.bg.img = null;
    state.cal = { active:false, p1:null, p2:null, pxPerMeter:null };
    draw();
  };

  // ===== Pipe controls =====
  function finishPipe(){
    if (!state.drawingPipe) return;
    if (state.drawingPipe.pts.length >= 2){
      state.pipes.push({ pts: [...state.drawingPipe.pts] });
    }
    state.drawingPipe = null;
    draw();
  }
  function cancelPipe(){
    state.drawingPipe = null;
    draw();
  }
  document.getElementById('btnFinish').onclick = finishPipe;
  document.getElementById('btnCancel').onclick = cancelPipe;

  // Clear all
  document.getElementById('btnClear').onclick = () => {
    state.pool = null; state.source = null; state.blocks = []; state.pipes = [];
    state.drawingPipe = null; state.drawingBlock = null;
    state.cal = { active:false, p1:null, p2:null, pxPerMeter:null };
    draw();
  };

  // ===== Keyboard shortcuts =====
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // ESC: abbruch (Pipe oder Kalibrierung)
      if (state.drawingPipe) { cancelPipe(); return; }
      if (state.cal.active) { state.cal.active=false; state.cal.p1=null; state.cal.p2=null; setTool(tools.PIPE); draw(); return; }
    }
    if (e.key === 'Enter') {
      // ENTER: Pipe fertig
      if (state.drawingPipe) { finishPipe(); return; }
    }
  });

  // ===== Mouse handling =====
  let lastClickTime = 0;

  canvas.addEventListener('mouseenter', () => { state.mouseInCanvas = true; draw(); });
  canvas.addEventListener('mouseleave', () => {
    state.mouseInCanvas = false;
    if (state.drawingPipe) delete state.drawingPipe.preview; // wichtig: nix "klebt"
    state.dragging = null;
    state.draggingBg = null;
    draw();
  });

  canvas.addEventListener('mousedown', (e) => {
    const p = getPos(e);
    const sp = {x:snap(p.x), y:snap(p.y)};

    // CALIBRATION clicks
    if (tool === tools.CAL && state.cal.active) {
      if (!state.cal.p1) state.cal.p1 = sp;
      else if (!state.cal.p2) {
        state.cal.p2 = sp;
        const px = Math.hypot(state.cal.p2.x - state.cal.p1.x, state.cal.p2.y - state.cal.p1.y);
        const meters = Number(prompt("Wie viele Meter sind das in echt? (z.B. 12.4)"));
        if (meters > 0) {
          state.cal.pxPerMeter = px / meters; // Pixel pro Meter
          state.cal.active = false;
          setTool(tools.PIPE);
        } else {
          alert("Ungültiger Wert. Bitte erneut kalibrieren.");
          state.cal.p1 = null; state.cal.p2 = null;
        }
      }
      draw();
      return;
    }

    if (tool === tools.MOVE){
      // object drag or background drag
      const hit = hitTestObjects(p);
      if (hit){
        state.dragging = { type: hit.type, ref: hit.ref, ox: p.x - hit.ref.x, oy: p.y - hit.ref.y };
        canvas.style.cursor = 'grabbing';
      } else if (state.bg.img) {
        state.draggingBg = { ox: p.x, oy: p.y, startX: state.bg.x, startY: state.bg.y };
        canvas.style.cursor = 'grabbing';
      }
      return;
    }

    if (tool === tools.POOL){
      state.pool = { x: sp.x, y: sp.y, w: state.grid*6, h: state.grid*4 };
      draw();
      return;
    }

    if (tool === tools.SOURCE){
      state.source = { x: sp.x, y: sp.y };
      draw();
      return;
    }

    if (tool === tools.BLOCK){
      state.drawingBlock = { x0: sp.x, y0: sp.y, x1: sp.x, y1: sp.y };
      draw();
      return;
    }

    if (tool === tools.PIPE){
      const now = performance.now();
      const isDouble = (now - lastClickTime) < 320;
      lastClickTime = now;

      if (!state.drawingPipe){
        state.drawingPipe = { pts: [sp] };
      } else {
        const pts = state.drawingPipe.pts;
        const last = pts[pts.length - 1];
        if (last.x !== sp.x || last.y !== sp.y) pts.push(sp);
      }

      if (isDouble && state.drawingPipe.pts.length >= 2){
        finishPipe();
      } else {
        draw();
      }
      return;
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const p = getPos(e);
    const sp = {x:snap(p.x), y:snap(p.y)};

    if (state.dragging){
      const r = state.dragging.ref;
      r.x = snap(p.x - state.dragging.ox);
      r.y = snap(p.y - state.dragging.oy);
      draw();
      return;
    }

    if (state.draggingBg){
      state.bg.x = state.draggingBg.startX + (p.x - state.draggingBg.ox);
      state.bg.y = state.draggingBg.startY + (p.y - state.draggingBg.oy);
      draw();
      return;
    }

    if (tool === tools.BLOCK && state.drawingBlock){
      state.drawingBlock.x1 = sp.x;
      state.drawingBlock.y1 = sp.y;
      draw();
      return;
    }

    // Pipe preview only while mouse is in canvas (damit im Menü nix folgt)
    if (tool === tools.PIPE && state.drawingPipe && state.mouseInCanvas){
      state.drawingPipe.preview = sp;
      draw();
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (state.dragging) state.dragging = null;
    if (state.draggingBg) state.draggingBg = null;
    canvas.style.cursor = (tool === tools.MOVE) ? 'grab' : 'crosshair';

    if (tool === tools.BLOCK && state.drawingBlock){
      const r = toRect(state.drawingBlock.x0, state.drawingBlock.y0, state.drawingBlock.x1, state.drawingBlock.y1);
      if (r.w >= state.grid && r.h >= state.grid) state.blocks.push(r);
      state.drawingBlock = null;
      draw();
    }
  });

  // Zoom background with wheel (only if bg exists)
  canvas.addEventListener('wheel', (e) => {
    if (!state.bg.img) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const oldScale = state.bg.scale;
    const factor = (e.deltaY < 0) ? 1.08 : 0.92;
    const newScale = Math.max(0.1, Math.min(10, oldScale * factor));

    // zoom around mouse point
    const img = state.bg.img;
    const beforeX = (mx - state.bg.x) / oldScale;
    const beforeY = (my - state.bg.y) / oldScale;

    state.bg.scale = newScale;
    state.bg.x = mx - beforeX * newScale;
    state.bg.y = my - beforeY * newScale;

    draw();
  }, { passive:false });

  // ===== BOM =====
  function calcBOM(){
    const g = state.grid;
    const diam = Math.round(Number(diamInput.value) || 50);

    let totalPx = 0;
    let elbows = 0;
    let segments = 0;
    let connectors = 0;
    let warnings = [];

    function addPolyline(pl){
      const pts = pl.pts;
      for (let i=0;i<pts.length-1;i++){
        const a=pts[i], b=pts[i+1];
        totalPx += Math.hypot(b.x-a.x, b.y-a.y);
        segments++;
      }
      if (pts.length >= 3) elbows += (pts.length - 2);
      if (pts.length >= 2){
        connectors += 2;
        connectors += Math.max(0, pts.length - 2);
      }

      // warning if crossing blocks
      for (let i=0;i<pts.length-1;i++){
        const a=pts[i], b=pts[i+1];
        const steps = 20;
        for (let s=0;s<=steps;s++){
          const t=s/steps;
          const x=a.x+(b.x-a.x)*t, y=a.y+(b.y-a.y)*t;
          for (const bl of state.blocks){
            if (x>=bl.x && x<=bl.x+bl.w && y>=bl.y && y<=bl.y+bl.h){
              warnings.push('Leitung schneidet eine Sperrzone. Bitte Route anpassen.');
              s=steps+1; i=pts.length; break;
            }
          }
        }
      }
    }

    state.pipes.forEach(addPolyline);
    if (state.drawingPipe && state.drawingPipe.pts?.length>=2) addPolyline(state.drawingPipe);

    // meters calculation:
    let totalMeters = 0;
    if (state.cal.pxPerMeter) {
      totalMeters = totalPx / state.cal.pxPerMeter; // echte Meter
    } else {
      const metersPerCell = Math.max(0.1, Number(scaleInput.value) || 0.5);
      const totalCells = totalPx / g;
      totalMeters = totalCells * metersPerCell;
    }

    // simple pipe sticks assumption (demo)
    const stickLen = 1; // m
    const sticks = Math.ceil(totalMeters / stickLen);
    const waste = Math.max(0, sticks*stickLen - totalMeters);

    if (!state.source) warnings.push('Keine Wasserquelle gesetzt.');
    if (!state.pool) warnings.push('Kein Pool/Ziel gesetzt (für Bewässerung kannst du das später als Zone nutzen).');
    if (totalMeters === 0) warnings.push('Noch keine Leitung gezeichnet.');

    if (state.cal.pxPerMeter) {
      warnings.push('Maßstab aktiv (kalibriert): Leitungslängen sind maßgetreu.');
    } else {
      warnings.push('Maßstab nicht kalibriert: Es gilt „Meter pro Rasterfeld“ als Schätzung.');
    }

    return { diam, totalMeters, sticks, waste, elbows, connectors, segments, warnings: [...new Set(warnings)] };
  }

  function renderBOM(){
    const b = calcBOM();
    bomEl.innerHTML = `
      <div>Rohr-Ø (Demo)</div><div>${b.diam} mm</div>
      <div>Leitungslänge</div><div>${b.totalMeters.toFixed(2)} m</div>
      <div>Rohre (1 m Stangen)</div><div>${b.sticks} Stk</div>
      <div>Verschnitt (Schätzung)</div><div>${b.waste.toFixed(2)} m</div>
      <div>Winkel 90° (Ecken)</div><div>${b.elbows} Stk</div>
      <div>Verbinder/Muffen</div><div>${b.connectors} Stk</div>
      <div>Segmente</div><div>${b.segments}</div>
    `;
    warnEl.textContent = b.warnings.length ? ("Hinweise: " + b.warnings.join(" · ")) : "";
  }

  // ===== Drawing =====
  function drawBackground(){
    if (!state.bg.img) return;
    const img = state.bg.img;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.drawImage(img, state.bg.x, state.bg.y, img.width * state.bg.scale, img.height * state.bg.scale);
    ctx.restore();
  }

  function drawGrid(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const g = state.grid;
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#2b3a4d';
    ctx.lineWidth = 1;

    for (let x=0; x<w; x+=g){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for (let y=0; y<h; y+=g){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawBlocks(){
    ctx.save();
    ctx.fillStyle = 'rgba(255,80,80,0.18)';
    ctx.strokeStyle = 'rgba(255,120,120,0.8)';
    ctx.lineWidth = 2;

    for (const b of state.blocks){
      roundRect(ctx, b.x, b.y, b.w, b.h, 10);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,170,170,0.9)';
      ctx.font = '12px system-ui';
      ctx.fillText('SPERRZONE', b.x + 10, b.y + 18);
      ctx.fillStyle = 'rgba(255,80,80,0.18)';
    }
    if (state.drawingBlock){
      const r = toRect(state.drawingBlock.x0, state.drawingBlock.y0, state.drawingBlock.x1, state.drawingBlock.y1);
      roundRect(ctx, r.x, r.y, r.w, r.h, 10);
      ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  function drawPool(){
    if (!state.pool) return;
    const r = state.pool;
    ctx.save();
    ctx.fillStyle = '#143a60';
    ctx.strokeStyle = '#5aa7ff';
    ctx.lineWidth = 2;
    roundRect(ctx, r.x, r.y, r.w, r.h, 12);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#e8eef6';
    ctx.font = '12px system-ui';
    ctx.fillText('POOL / ZIEL', r.x + 10, r.y + 18);
    ctx.restore();
  }

  function drawSource(){
    if (!state.source) return;
    const s = state.source;
    ctx.save();
    ctx.fillStyle = '#1f8cff';
    ctx.strokeStyle = '#cbe4ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(s.x, s.y, 7, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#e8eef6';
    ctx.font = '12px system-ui';
    ctx.fillText('WASSER', s.x + 10, s.y + 4);
    ctx.restore();
  }

  function drawPipes(){
    ctx.save();
    ctx.strokeStyle = '#7ee787';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    function drawPolyline(pl, preview=false){
      const pts = pl.pts || [];
      if (pts.length < 1) return;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      if (preview && pl.preview) ctx.lineTo(pl.preview.x, pl.preview.y);
      ctx.stroke();

      ctx.fillStyle = '#c9f7cf';
      for (const p of pts){
        ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
      }
      if (preview && pl.preview){
        ctx.fillStyle = '#dfffe3';
        ctx.beginPath(); ctx.arc(pl.preview.x, pl.preview.y, 4, 0, Math.PI*2); ctx.fill();
      }
    }

    state.pipes.forEach(pl => drawPolyline(pl, false));
    if (state.drawingPipe) drawPolyline(state.drawingPipe, true);

    ctx.restore();
  }

  function drawCalibration(){
    if (!state.cal.p1) return;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);

    const p1 = state.cal.p1;
    const p2 = state.cal.p2 || (state.mouseInCanvas && state.drawingPipe?.preview ? state.drawingPipe.preview : null);

    if (state.cal.p2){
      ctx.beginPath();
      ctx.moveTo(state.cal.p1.x, state.cal.p1.y);
      ctx.lineTo(state.cal.p2.x, state.cal.p2.y);
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '12px system-ui';
      const px = Math.hypot(state.cal.p2.x-state.cal.p1.x, state.cal.p2.y-state.cal.p1.y);
      const txt = state.cal.pxPerMeter ? `Kalibriert` : `Strecke: ${px.toFixed(0)} px`;
      ctx.fillText(txt, (state.cal.p1.x+state.cal.p2.x)/2 + 8, (state.cal.p1.y+state.cal.p2.y)/2 - 8);
    } else {
      // show first point
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath(); ctx.arc(p1.x, p1.y, 5, 0, Math.PI*2); ctx.fill();
      ctx.font = '12px system-ui';
      ctx.fillText('Kalibrierung: Punkt 1 gesetzt', p1.x + 10, p1.y - 10);
    }

    ctx.restore();
  }

  function drawHUD(){
    const label = ({
      [tools.PIPE]:'Leitung zeichnen',
      [tools.POOL]:'Pool/Ziel platzieren',
      [tools.SOURCE]:'Wasserquelle setzen',
      [tools.BLOCK]:'Sperrzone zeichnen',
      [tools.MOVE]:'Verschieben (Objekte / Bild)',
      [tools.CAL]:'Maßstab kalibrieren',
    })[tool];

    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1;
    roundRect(ctx, 12, 12, 240, 34, 12);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#e8eef6';
    ctx.font = '12px system-ui';
    ctx.fillText('Tool: ' + label, 22, 33);
    ctx.restore();
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    drawBackground();
    drawGrid();
    drawBlocks();
    drawPool();
    drawSource();
    drawPipes();
    drawCalibration();
    drawHUD();
    renderBOM();
  }

  // ===== roundRect helper =====
  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Sync
  scaleInput.addEventListener('input', draw);
  diamInput.addEventListener('input', draw);

  // Start
  resize();
})();
</script>
</body>
</html>
