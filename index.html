<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PVC WELT Planer Demo – Version 2</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121a23; --panel2:#0f1722; --line:#1f2a36;
      --text:#e8eef6; --muted:#9fb0c3; --accent:#5aa7ff;
      --ok:#7ee787; --warn:#ffb86b; --bad:#ff5b5b;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:0;background:var(--bg);color:var(--text)}
    header{padding:14px 16px;border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header b{letter-spacing:.2px}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid #2a3a50;background:var(--panel2);color:var(--muted);font-size:12px}
    .wrap{display:grid;grid-template-columns:440px 1fr;gap:12px;padding:12px}
    .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;overflow:hidden}
    .panel h3{margin:0;padding:12px 12px 10px;border-bottom:1px solid var(--line);font-size:14px;color:var(--muted)}
    .content{padding:12px;max-height:calc(100vh - 104px);overflow:auto}
    .step{border:1px solid #223144;background:rgba(255,255,255,.02);border-radius:14px;padding:12px;margin-bottom:10px;transition:border-color .2s, box-shadow .2s;}
    .step.activeStep{border-color:rgba(90,167,255,.55);box-shadow:0 0 0 2px rgba(90,167,255,.10) inset}
    .step.done{border-color:rgba(126,231,135,.45);box-shadow:0 0 0 2px rgba(126,231,135,.10) inset}
    .stepHeader{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .badge{display:inline-flex;align-items:center;justify-content:center;min-width:24px;height:24px;padding:0 8px;border-radius:999px;border:1px solid #2a3a50;background:var(--panel2);color:var(--muted);font-size:12px}
    .badge.ok{border-color:rgba(126,231,135,.5);color:var(--ok)}
    .badge.warn{border-color:rgba(255,184,107,.5);color:var(--warn)}
    .badge.bad{border-color:rgba(255,91,91,.55);color:var(--bad)}
    .stepTitle{font-weight:800;font-size:13px}
    .stepDesc{color:var(--muted);font-size:12px;line-height:1.35;margin:8px 0 0}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:#192434;border:1px solid #2a3a50;color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer;font-size:13px}
    button.primary{border-color:rgba(90,167,255,.55);box-shadow:0 0 0 1px rgba(90,167,255,.15) inset}
    button:disabled{opacity:.45;cursor:not-allowed}
    button:hover{filter:brightness(1.06)}
    label{font-size:12px;color:var(--muted);display:block;margin-top:10px;margin-bottom:6px}
    input[type="number"],input[type="file"],select{
      width:100%;padding:9px 10px;border-radius:10px;border:1px solid #2a3a50;background:var(--panel2);color:var(--text)
    }
    .split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .hint{color:var(--muted);font-size:12px;line-height:1.35;margin-top:8px}
    .ok{color:var(--ok)} .warn{color:var(--warn)}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px 10px;font-size:13px}
    .kv div{padding:4px 0;border-bottom:1px dashed #243245}
    .kv div:nth-last-child(-n+2){border-bottom:0}
    .small{color:var(--muted);font-size:12px;line-height:1.35;margin-top:8px}
    .canvasWrap{position:relative}
    canvas{width:100%;height:calc(100vh - 88px);display:block;background:#0b0f14}
    .hud{
      position:absolute;top:12px;left:12px;right:12px;max-width:900px;
      background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);
      border-radius:12px;padding:10px 12px;font-size:12px;color:var(--text);backdrop-filter:blur(4px)
    }
    .toast{
      position:absolute;bottom:14px;left:14px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.14);
      color:var(--text);padding:10px 12px;border-radius:12px;font-size:12px;
      opacity:0;transform:translateY(6px);transition:opacity .2s, transform .2s;
      pointer-events:none;max-width:740px
    }
    .toast.show{opacity:1;transform:translateY(0)}
    .footerRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .kbd{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 6px;border-radius:6px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);font-size:11px;color:var(--text)}
    .toggleRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid #2a3a50;background:var(--panel2);color:var(--muted);font-size:12px}
    .chip input{width:auto}

    /* optional mini error bar */
    .errbar{
      position:absolute;top:10px;right:12px;max-width:420px;
      background:rgba(255,91,91,.18);border:1px solid rgba(255,91,91,.35);
      color:rgba(255,255,255,.92);padding:8px 10px;border-radius:12px;
      font-size:12px;display:none
    }
    .errbar.show{display:block}
  </style>
</head>
<body>
<header>
  <b>PVC WELT Planer Demo – Version 2</b>
  <span class="pill">Geradeziehen • Kalibrieren • Sperrzonen • Leitungen</span>
  <span class="pill">Zoom: <b>Ctrl + Mausrad</b></span>
</header>

<div class="wrap">
  <div class="panel">
    <h3>Schritt-für-Schritt</h3>
    <div class="content">

      <div class="step" id="step1">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">1</span><div class="stepTitle">Bild einfügen</div>
          </div>
          <span class="badge" id="s1">offen</span>
        </div>
        <div class="stepDesc">Google Earth Screenshot / Vogelperspektive oder Skizze hochladen.</div>
        <label>Bild hochladen</label>
        <input id="bgFile" type="file" accept="image/*" />
        <div class="row">
          <button id="btnFit" class="primary" disabled>Bild einpassen</button>
          <button id="btnMoveAll" disabled>Verschieben-Modus</button>
          <button id="btnRemove" disabled>Bild entfernen</button>
        </div>
        <div class="hint">Zoomen im Plan geht nur mit <b>Ctrl + Mausrad</b>, damit du links normal scrollen kannst.</div>
      </div>

      <div class="step" id="step2">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">2</span><div class="stepTitle">Bild gerade ziehen</div>
          </div>
          <span class="badge" id="s2">optional</span>
        </div>
        <div class="stepDesc">„Start“ drücken → Punkt 1 klicken → Punkt 2 klicken (Kante) → Bild dreht sich. Wiederholbar.</div>
        <div class="row">
          <button id="btnStraight" class="primary" disabled>Geradeziehen starten</button>
          <button id="btnStraightReset" disabled>Zurücksetzen</button>
        </div>
      </div>

      <div class="step" id="step3">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">3</span><div class="stepTitle">Maßstab einstellen</div>
          </div>
          <span class="badge" id="s3">offen</span>
        </div>
        <div class="stepDesc">„Start“ drücken → 2 Punkte klicken → Meter eingeben.</div>
        <div class="row">
          <button id="btnCal" class="primary" disabled>Kalibrierung starten</button>
          <button id="btnCalReset" disabled>Zurücksetzen</button>
        </div>

        <div class="split">
          <div>
            <label>Bekannte Länge (m)</label>
            <input id="calMeters" type="number" step="0.01" min="0" placeholder="z. B. 12.40" disabled />
          </div>
          <div>
            <label>Fallback: Meter pro Rasterfeld</label>
            <input id="fallbackScale" type="number" min="0.1" step="0.1" value="0.5" />
          </div>
        </div>

        <div class="split">
          <div>
            <label>Raster-Größe</label>
            <select id="gridSize">
              <option value="40">Groß (40px)</option>
              <option value="32" selected>Normal (32px)</option>
              <option value="24">Fein (24px)</option>
              <option value="16">Sehr fein (16px)</option>
            </select>
          </div>
          <div>
            <label>Einrasten innerhalb Raster</label>
            <select id="snapMode">
              <option value="8">Sehr fein (1/8)</option>
              <option value="4" selected>Fein (1/4)</option>
              <option value="2">Mittel (1/2)</option>
              <option value="1">Grob (1/1)</option>
              <option value="0">Ganz genau (ohne Raster)</option>
            </select>
          </div>
        </div>

        <div class="split">
          <div>
            <label>Rohr-Ø (Demo)</label>
            <input id="diam" type="number" min="16" step="1" value="50" />
          </div>
          <div>
            <label>Raster anzeigen</label>
            <select id="gridMode">
              <option value="grid" selected>anzeigen</option>
              <option value="none">aus</option>
            </select>
          </div>
        </div>

        <div class="hint"><span class="ok" id="calOk"></span> <span class="warn" id="calWarn"></span></div>
      </div>

      <div class="step" id="step4">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">4</span><div class="stepTitle">Wasserquelle setzen</div>
          </div>
          <span class="badge" id="s4">offen</span>
        </div>
        <div class="stepDesc">Button drücken → Klick im Plan.</div>
        <div class="row">
          <button id="btnSource" class="primary" disabled>Wasserquelle setzen</button>
        </div>
      </div>

      <div class="step" id="step5">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">5</span><div class="stepTitle">Pool platzieren + verschieben</div>
          </div>
          <span class="badge" id="s5">offen</span>
        </div>
        <div class="stepDesc">Pool setzen, dann optional „Pool verschieben“ drücken und ziehen.</div>

        <div class="split">
          <div>
            <label>Pool-Form</label>
            <select id="poolShape" disabled>
              <option value="rect">Rechteckig</option>
              <option value="round">Rund</option>
            </select>
          </div>
          <div>
            <label>—</label>
            <button id="btnPoolMove" disabled>Pool verschieben</button>
          </div>
        </div>

        <div class="split">
          <div>
            <label id="wLabel">Breite (m)</label>
            <input id="poolW" type="number" min="0.5" step="0.1" value="3.0" disabled />
          </div>
          <div>
            <label id="hLabel">Länge (m)</label>
            <input id="poolH" type="number" min="0.5" step="0.1" value="2.0" disabled />
          </div>
        </div>

        <div class="row">
          <button id="btnPool" class="primary" disabled>Pool/Ziel setzen</button>
        </div>
        <div class="hint" id="poolLive"></div>
      </div>

      <div class="step" id="step6">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">6</span><div class="stepTitle">Sperrzonen (flexibel)</div>
          </div>
          <span class="badge" id="s6">optional</span>
        </div>
        <div class="stepDesc"><b>Freihand:</b> halten & malen. <b>Polygon:</b> Punkte klicken, <span class="kbd">Enter</span> fertig.</div>
        <div class="row">
          <button id="btnBlockFree" disabled class="primary">Sperrzone Freihand</button>
          <button id="btnBlockPoly" disabled>Sperrzone Polygon</button>
          <button id="btnBlocksClear" disabled>Alle Sperrzonen löschen</button>
        </div>
      </div>

      <div class="step" id="step7">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">7</span><div class="stepTitle">Leitung zeichnen</div>
          </div>
          <span class="badge" id="s7">offen</span>
        </div>
        <div class="stepDesc">
          1. Klick startet • Linie folgt Maus • Klick setzt nächsten Punkt • <b>Doppelklick = fertig</b> • <span class="kbd">Esc</span> abbrechen.
        </div>
        <div class="row">
          <button id="btnPipe" class="primary" disabled>Leitung zeichnen</button>
          <button id="btnPipeCancel" disabled>Abbrechen</button>
        </div>
        <div class="toggleRow">
          <label class="chip"><input type="checkbox" id="showMeasures" checked>Maße/Längen</label>
        </div>
      </div>

      <div class="step" id="out">
        <div class="stepHeader">
          <div style="display:flex;align-items:center;gap:10px">
            <span class="badge">✔</span><div class="stepTitle">Bestellübersicht</div>
          </div>
          <span class="badge ok">bereit</span>
        </div>
        <div class="stepDesc">Stückliste (Demo) + PDF Export.</div>
        <div class="kv" id="bom"></div>
        <div class="small" id="warn"></div>
        <div class="footerRow">
          <button id="btnPDF" class="primary">PDF herunterladen</button>
          <button id="btnPlanClear">Plan löschen</button>
          <button id="btnResetAll">Alles zurücksetzen</button>
        </div>
      </div>

    </div>
  </div>

  <div class="panel canvasWrap">
    <div class="hud" id="hud"><b>PVC WELT Planer Demo – Version 2</b> • Schritt 1: Bild hochladen.</div>
    <div class="errbar" id="errbar"></div>
    <div class="toast" id="toast">OK</div>
    <canvas id="c"></canvas>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
(() => {
  const VERSION = 2;

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const hud = document.getElementById('hud');
  const toast = document.getElementById('toast');
  const errbar = document.getElementById('errbar');

  // --- global error catcher (zeigt, wenn Script irgendwo crasht)
  window.addEventListener('error', (ev) => {
    const msg = (ev && ev.message) ? ev.message : 'Unbekannter Fehler';
    errbar.textContent = 'Fehler: ' + msg + ' (Bitte Screenshot schicken)';
    errbar.classList.add('show');
  });

  // UI
  const bgFile = document.getElementById('bgFile');
  const btnFit = document.getElementById('btnFit');
  const btnMoveAll = document.getElementById('btnMoveAll');
  const btnRemove = document.getElementById('btnRemove');

  const btnStraight = document.getElementById('btnStraight');
  const btnStraightReset = document.getElementById('btnStraightReset');

  const btnCal = document.getElementById('btnCal');
  const btnCalReset = document.getElementById('btnCalReset');
  const calMeters = document.getElementById('calMeters');
  const fallbackScale = document.getElementById('fallbackScale');
  const gridSize = document.getElementById('gridSize');
  const snapMode = document.getElementById('snapMode');
  const diamInput = document.getElementById('diam');
  const gridMode = document.getElementById('gridMode');
  const calOk = document.getElementById('calOk');
  const calWarn = document.getElementById('calWarn');

  const btnSource = document.getElementById('btnSource');

  const poolShape = document.getElementById('poolShape');
  const poolW = document.getElementById('poolW');
  const poolH = document.getElementById('poolH');
  const wLabel = document.getElementById('wLabel');
  const hLabel = document.getElementById('hLabel');
  const poolLive = document.getElementById('poolLive');
  const btnPool = document.getElementById('btnPool');
  const btnPoolMove = document.getElementById('btnPoolMove');

  const btnBlockFree = document.getElementById('btnBlockFree');
  const btnBlockPoly  = document.getElementById('btnBlockPoly');
  const btnBlocksClear = document.getElementById('btnBlocksClear');

  const btnPipe = document.getElementById('btnPipe');
  const btnPipeCancel = document.getElementById('btnPipeCancel');
  const showMeasures = document.getElementById('showMeasures');

  const bomEl = document.getElementById('bom');
  const warnEl = document.getElementById('warn');

  const btnPDF = document.getElementById('btnPDF');
  const btnPlanClear = document.getElementById('btnPlanClear');
  const btnResetAll = document.getElementById('btnResetAll');

  const s1 = document.getElementById('s1');
  const s2 = document.getElementById('s2');
  const s3 = document.getElementById('s3');
  const s4 = document.getElementById('s4');
  const s5 = document.getElementById('s5');
  const s6 = document.getElementById('s6');
  const s7 = document.getElementById('s7');

  const stepEls = {
    step1: document.getElementById('step1'),
    step2: document.getElementById('step2'),
    step3: document.getElementById('step3'),
    step4: document.getElementById('step4'),
    step5: document.getElementById('step5'),
    step6: document.getElementById('step6'),
    step7: document.getElementById('step7'),
    out: document.getElementById('out'),
  };

  const tools = {
    NONE:'none',
    MOVE_ALL:'move_all',
    MOVE_POOL:'move_pool',
    STRAIGHT:'straight',
    CAL:'cal',
    SOURCE:'source',
    POOL:'pool',
    BLOCK_FREE:'block_free',
    BLOCK_POLY:'block_poly',
    PIPE:'pipe',
  };
  let tool = tools.NONE;

  // demo catalog
  const catalog = {
    pipe: (diam) => ({ sku:`PVC-ROHR-${diam}`, name:`PVC Rohr Ø${diam} (Meterware)`, unit:'m' }),
    elbow90: (diam) => ({ sku:`PVC-WINKEL90-${diam}`, name:`Winkel 90° Ø${diam}`, unit:'Stk' }),
    connector: (diam) => ({ sku:`PVC-MUFFE-${diam}`, name:`Muffe/Verbinder Ø${diam}`, unit:'Stk' }),
    glue: () => ({ sku:`PVC-KLEBER`, name:`PVC Kleber (Beispiel)`, unit:'Stk' }),
    cleaner: () => ({ sku:`PVC-REINIGER`, name:`Reiniger/Primer (Beispiel)`, unit:'Stk' }),
    tape: () => ({ sku:`DICHTBAND`, name:`Dichtband (Beispiel)`, unit:'Stk' }),
  };

  // state
  const state = {
    grid: 32,
    bg: { img:null, x:0, y:0, scale:1, rot:0 },
    bgDrag: null,
    straighten: { active:false, p1:null, preview:null },
    cal: { active:false, p1:null, p2:null, pxPerMeter:null },
    source: null,
    pool: null,
    blocks: [],
    drawingFree: null,
    drawingPoly: null,
    pipes: [],
    drawingPipe: null,
    draggingObj: null,
    pointerInCanvas: false,
  };

  // ====== helpers UI ======
  function setHud(html){ hud.innerHTML = html; }
  function showToast(text){
    toast.textContent = text;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove('show'), 1200);
  }
  function enable(el, on){ el.disabled = !on; }
  function badgeSet(el, text, mode){
    el.textContent = text;
    el.classList.remove('ok','warn','bad');
    if(mode) el.classList.add(mode);
  }
  function activateStep(id){
    Object.values(stepEls).forEach(s => s.classList.remove('activeStep'));
    const el = stepEls[id];
    if(!el) return;
    el.classList.add('activeStep');
    el.scrollIntoView({behavior:'smooth', block:'nearest'});
  }
  function markDone(id, done){
    const el = stepEls[id];
    if(!el) return;
    el.classList.toggle('done', !!done);
  }

  // ===== geometry =====
  function getPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }
  function snapValue(v){
    const mode = Number(snapMode.value || 4);
    if(mode === 0) return v;
    const step = state.grid / mode;
    return Math.round(v / step) * step;
  }
  function snapPoint(p){ return { x: snapValue(p.x), y: snapValue(p.y) }; }
  function dist(a,b){ return Math.hypot(b.x-a.x, b.y-a.y); }

  // ===== robust rounded rect (fix for browsers without ctx.roundRect) =====
  function roundedRectPath(x,y,w,h,r){
    const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  // ===== rotation mapping =====
  function bgCenter(){
    const rect = canvas.getBoundingClientRect();
    if(!state.bg.img) return {x: rect.width/2, y: rect.height/2};
    const w = state.bg.img.width * state.bg.scale;
    const h = state.bg.img.height * state.bg.scale;
    return { x: state.bg.x + w/2, y: state.bg.y + h/2 };
  }
  function screenToWorld(ps){
    const c = bgCenter();
    const a = -state.bg.rot;
    const dx = ps.x - c.x;
    const dy = ps.y - c.y;
    return {
      x: dx*Math.cos(a) - dy*Math.sin(a) + c.x,
      y: dx*Math.sin(a) + dy*Math.cos(a) + c.y
    };
  }

  // ===== scale conversion =====
  function metersToPx(m){
    if(state.cal.pxPerMeter) return m * state.cal.pxPerMeter;
    const metersPerCell = Math.max(0.1, Number(fallbackScale.value) || 0.5);
    return (m / metersPerCell) * state.grid;
  }
  function pxToMeters(px){
    if(state.cal.pxPerMeter) return px / state.cal.pxPerMeter;
    const metersPerCell = Math.max(0.1, Number(fallbackScale.value) || 0.5);
    return (px / state.grid) * metersPerCell;
  }

  // ===== background fit/resize =====
  function fitBackground(){
    if(!state.bg.img) return;
    const rect = canvas.getBoundingClientRect();
    const img = state.bg.img;
    const sx = rect.width / img.width;
    const sy = rect.height / img.height;
    const s = Math.min(sx, sy);
    state.bg.scale = s;
    state.bg.x = (rect.width - img.width*s)/2;
    state.bg.y = (rect.height - img.height*s)/2;
  }
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', resize);

  // ===== pool UI =====
  function updatePoolLabels(){
    const shape = poolShape.value;
    if(shape === 'round'){
      wLabel.textContent = 'Durchmesser (m)';
      hLabel.textContent = '—';
      poolH.disabled = true;
      poolH.value = poolW.value;
    } else {
      wLabel.textContent = 'Breite (m)';
      hLabel.textContent = 'Länge (m)';
      poolH.disabled = false;
    }
    updatePoolLive();
  }
  function updatePoolLive(){
    const shape = poolShape.value;
    const w = Number(poolW.value||0);
    const h = Number(poolH.value||0);
    if(shape === 'round'){
      const d = w;
      const area = Math.PI*(d/2)*(d/2);
      poolLive.innerHTML = `<span class="ok">Live:</span> Rund – Ø <b>${d.toFixed(2)} m</b> • Fläche <b>${area.toFixed(2)} m²</b>`;
    } else {
      const area = w*h;
      poolLive.innerHTML = `<span class="ok">Live:</span> Rechteck – <b>${w.toFixed(2)}×${h.toFixed(2)} m</b> • Fläche <b>${area.toFixed(2)} m²</b>`;
    }
  }
  function syncPoolIfPlaced(){
    if(!state.pool) return;
    const shape = poolShape.value;
    const wM = Number(poolW.value||0);
    const hM = (shape==='round') ? wM : Number(poolH.value||0);
    state.pool.shape = shape;
    state.pool.w = snapValue(metersToPx(wM));
    state.pool.h = snapValue(metersToPx(hM));
  }
  poolShape.addEventListener('change', ()=>{ updatePoolLabels(); syncPoolIfPlaced(); updateWizard(); });
  poolW.addEventListener('input', ()=>{ if(poolShape.value==='round') poolH.value=poolW.value; updatePoolLive(); syncPoolIfPlaced(); updateWizard(); });
  poolH.addEventListener('input', ()=>{ updatePoolLive(); syncPoolIfPlaced(); updateWizard(); });

  // ===== polygons =====
  function pointInPoly(pt, poly){
    const vs = poly.pts;
    let inside = false;
    for(let i=0, j=vs.length-1; i<vs.length; j=i++){
      const xi=vs[i].x, yi=vs[i].y;
      const xj=vs[j].x, yj=vs[j].y;
      const intersect = ((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-12)+xi);
      if(intersect) inside = !inside;
    }
    return inside;
  }

  function segmentCrossesBlocks(a,b){
    const length = dist(a,b);
    const steps = Math.max(10, Math.floor(length / 12));
    for(let s=0;s<=steps;s++){
      const t=s/steps;
      const p={x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t};
      for(const bl of state.blocks){
        if(pointInPoly(p, bl)) return true;
      }
    }
    return false;
  }

  // ===== hit tests =====
  function hitPool(p){
    if(!state.pool) return false;
    const pl = state.pool;
    if(pl.shape==='rect'){
      return p.x>=pl.x && p.x<=pl.x+pl.w && p.y>=pl.y && p.y<=pl.y+pl.h;
    } else {
      const cx = pl.x + pl.w/2;
      const cy = pl.y + pl.h/2;
      const r  = pl.w/2;
      return Math.hypot(p.x-cx, p.y-cy) <= r;
    }
  }
  function hitSource(p){
    if(!state.source) return false;
    return dist(p, state.source) <= 12;
  }

  // ===== BOM =====
  function calcBOM(){
    const diam = Math.round(Number(diamInput.value)||50);
    let totalPx=0, elbows=0, connectors=0, segments=0;
    const warnings=[];

    const addPolyline = (pts)=>{
      for(let i=0;i<pts.length-1;i++){
        totalPx += dist(pts[i], pts[i+1]);
        segments++;
        if(segmentCrossesBlocks(pts[i], pts[i+1])) warnings.push('Leitung schneidet eine Sperrzone. Bitte Route anpassen.');
      }
      if(pts.length>=3) elbows += (pts.length-2);
      if(pts.length>=2){
        connectors += 2;
        connectors += Math.max(0, pts.length-2);
      }
    };

    for(const p of state.pipes) addPolyline(p.pts);
    const totalM = pxToMeters(totalPx);

    if(!state.bg.img) warnings.push('Kein Hintergrundbild geladen.');
    if(!state.cal.pxPerMeter) warnings.push('Hinweis: Nicht kalibriert – Maße ggf. nur Schätzung.');
    if(!state.source) warnings.push('Keine Wasserquelle gesetzt.');
    if(!state.pool) warnings.push('Kein Pool/Ziel gesetzt.');
    if(totalM===0) warnings.push('Noch keine Leitung gezeichnet.');

    const items=[];
    items.push({...catalog.pipe(diam), qty:Number(totalM.toFixed(2))});
    items.push({...catalog.elbow90(diam), qty:elbows});
    items.push({...catalog.connector(diam), qty:connectors});
    if(totalM>0){
      items.push({...catalog.glue(), qty:1});
      items.push({...catalog.cleaner(), qty:1});
      items.push({...catalog.tape(), qty:1});
    }

    return {diam,totalM,elbows,connectors,segments,items,warnings:[...new Set(warnings)]};
  }

  function renderBOM(){
    const b=calcBOM();
    bomEl.innerHTML = `
      <div>Rohr-Ø (Demo)</div><div>${b.diam} mm</div>
      <div>Leitungslänge</div><div>${b.totalM.toFixed(2)} m</div>
      <div>Winkel 90°</div><div>${b.elbows} Stk</div>
      <div>Verbinder/Muffen</div><div>${b.connectors} Stk</div>
      <div>Segmente</div><div>${b.segments}</div>
    `;
    warnEl.textContent = b.warnings.length ? ('Hinweise: ' + b.warnings.join(' · ')) : '';
  }

  // ===== PDF =====
  btnPDF.onclick = ()=>{
    const b=calcBOM();
    const {jsPDF}=window.jspdf;
    const doc=new jsPDF({unit:'mm', format:'a4'});
    const margin=12;
    let y=14;

    function line(txt,bold=false){
      doc.setFont('helvetica', bold?'bold':'normal');
      doc.setFontSize(bold?12:10);
      doc.text(txt, margin, y);
      y += bold?7:5;
    }
    function hr(){
      doc.setDrawColor(180);
      doc.line(margin, y, 210-margin, y);
      y += 6;
    }

    line(`PVC WELT – Bestellübersicht (Demo) – Version ${VERSION}`, true);
    line('Projekt: Pool / Bewässerung Planung');
    hr();

    line('Stückliste (Beispiel)', true);
    doc.setFontSize(10);
    doc.setFont('helvetica','bold');
    doc.text('SKU', margin, y);
    doc.text('Artikel', margin+45, y);
    doc.text('Menge', 210-margin, y, {align:'right'});
    y += 6;
    doc.setFont('helvetica','normal');

    for(const it of b.items){
      const qty = (it.unit==='m') ? `${it.qty.toFixed(2)} ${it.unit}` : `${it.qty} ${it.unit}`;
      const nameLines = doc.splitTextToSize(it.name, 105);
      doc.text(it.sku, margin, y);
      doc.text(nameLines, margin+45, y);
      doc.text(qty, 210-margin, y, {align:'right'});
      y += Math.max(6, nameLines.length*5);
      if(y>270){ doc.addPage(); y=14; }
    }

    hr();
    line('Hinweise', true);
    const hints = b.warnings.length ? b.warnings : ['Keine Hinweise.'];
    for(const w of hints){
      const lines = doc.splitTextToSize('• '+w, 190);
      doc.text(lines, margin, y);
      y += lines.length*5;
      if(y>280){ doc.addPage(); y=14; }
    }

    doc.save('pvc-welt-bestelluebersicht-demo.pdf');
  };

  // ===== wizard =====
  function updateWizard(){
    const hasBg = !!state.bg.img;
    badgeSet(s1, hasBg?'ok':'offen', hasBg?'ok':null);
    markDone('step1', hasBg);

    const straightOk = Math.abs(state.bg.rot) > 0.0001;
    badgeSet(s2, straightOk?'ok':'optional', straightOk?'ok':null);
    markDone('step2', straightOk);

    if(!hasBg){
      badgeSet(s3,'offen',null);
      calOk.textContent=''; calWarn.textContent='';
    } else if(state.cal.pxPerMeter){
      badgeSet(s3,'ok','ok');
      calOk.textContent='✓ Maßstab aktiv – Längen sind maßgetreu.';
      calWarn.textContent='';
      markDone('step3', true);
    } else if(state.cal.active){
      badgeSet(s3,'in Arbeit','warn');
      calOk.textContent=''; calWarn.textContent='Klicke Punkt 1 und Punkt 2 im Plan.';
      markDone('step3', false);
    } else {
      badgeSet(s3,'offen','warn');
      calOk.textContent=''; calWarn.textContent='Empfohlen: Kalibrieren für echte Meter.';
      markDone('step3', false);
    }

    enable(btnFit, hasBg);
    enable(btnMoveAll, hasBg);
    enable(btnRemove, hasBg);
    enable(btnStraight, hasBg);
    enable(btnStraightReset, hasBg);
    enable(btnCal, hasBg);
    enable(btnCalReset, hasBg);
    enable(calMeters, hasBg && state.cal.p1 && state.cal.p2);

    enable(btnSource, hasBg);
    badgeSet(s4, state.source?'ok':'offen', state.source?'ok':null);
    markDone('step4', !!state.source);

    const canPool = !!state.source;
    enable(poolShape, canPool);
    enable(poolW, canPool);
    enable(poolH, canPool && poolShape.value!=='round');
    enable(btnPool, canPool);
    enable(btnPoolMove, !!state.pool);
    badgeSet(s5, state.pool?'ok':'offen', state.pool?'ok':null);
    markDone('step5', !!state.pool);

    const canBlocks = !!state.pool;
    enable(btnBlockFree, canBlocks);
    enable(btnBlockPoly, canBlocks);
    enable(btnBlocksClear, canBlocks && state.blocks.length>0);
    badgeSet(s6, state.blocks.length>0 ? 'ok' : 'optional', state.blocks.length>0 ? 'ok' : null);
    markDone('step6', state.blocks.length>0);

    const canPipe = !!(state.pool && state.source);
    enable(btnPipe, canPipe);
    enable(btnPipeCancel, !!state.drawingPipe);
    badgeSet(s7, state.pipes.length>0 ? 'ok' : 'offen', state.pipes.length>0 ? 'ok' : null);
    markDone('step7', state.pipes.length>0);

    if(!hasBg){
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Schritt 1: Bild hochladen.`);
      activateStep('step1');
    } else if(!state.cal.pxPerMeter){
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Schritt 2/3: Geradeziehen & Kalibrieren.`);
      activateStep('step3');
    } else if(!state.source){
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Schritt 4: Wasserquelle setzen.`);
      activateStep('step4');
    } else if(!state.pool){
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Schritt 5: Pool platzieren.`);
      activateStep('step5');
    } else if(state.pipes.length===0){
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Schritt 7: Leitung zeichnen (Doppelklick = fertig).`);
      activateStep('step7');
    } else {
      setHud(`<b>PVC WELT Planer Demo – Version ${VERSION}</b> • Fertig: Stückliste / PDF.`);
      activateStep('out');
    }

    renderBOM();
    draw();
  }

  // ===== reset =====
  function resetPlanning(){
    state.source=null; state.pool=null;
    state.blocks=[]; state.drawingFree=null; state.drawingPoly=null;
    state.pipes=[]; state.drawingPipe=null;
    state.draggingObj=null;

    state.cal={active:false,p1:null,p2:null,pxPerMeter:null};
    calMeters.value='';
    calOk.textContent=''; calWarn.textContent='';
  }
  function resetAll(){
    state.bg={img:null,x:0,y:0,scale:1,rot:0};
    state.bgDrag=null;
    state.straighten={active:false,p1:null,preview:null};
    resetPlanning();
    tool=tools.NONE;
    showToast('Alles zurückgesetzt');
    updateWizard();
  }

  // ===== input hooks =====
  gridSize.addEventListener('change', ()=>{
    state.grid = Number(gridSize.value||32);
    showToast('Raster geändert');
    draw();
  });
  snapMode.addEventListener('change', ()=>{ showToast('Einrasten geändert'); draw(); });
  fallbackScale.addEventListener('input', ()=>{ syncPoolIfPlaced(); updatePoolLive(); draw(); });
  diamInput.addEventListener('input', draw);
  gridMode.addEventListener('change', draw);
  showMeasures.addEventListener('change', draw);

  // ===== bg upload =====
  bgFile.addEventListener('change', (e)=>{
    const file=e.target.files?.[0];
    if(!file) return;
    const img=new Image();
    img.onload=()=>{
      state.bg.img=img;
      state.bg.rot=0;
      fitBackground();
      resetPlanning();
      tool=tools.NONE;
      showToast('Bild geladen');
      updateWizard();
    };
    img.src=URL.createObjectURL(file);
  });

  // ===== buttons =====
  btnFit.onclick = ()=>{ fitBackground(); showToast('Bild eingepasst'); draw(); };
  btnRemove.onclick = ()=>resetAll();

  btnMoveAll.onclick = ()=>{
    tool = (tool===tools.MOVE_ALL) ? tools.NONE : tools.MOVE_ALL;
    showToast(tool===tools.MOVE_ALL ? 'Verschieben-Modus AN' : 'Verschieben-Modus AUS');
  };

  btnStraight.onclick = ()=>{
    tool=tools.STRAIGHT;
    state.straighten.active=true;
    state.straighten.p1=null; state.straighten.preview=null;
    showToast('Geradeziehen: 2 Punkte klicken');
    setHud(`<b>Version ${VERSION}</b> • Geradeziehen: Punkt 1 klicken, dann Punkt 2.`);
    updateWizard();
  };
  btnStraightReset.onclick = ()=>{
    state.bg.rot=0;
    showToast('Geradeziehen zurückgesetzt');
    updateWizard();
  };

  btnCal.onclick = ()=>{
    tool=tools.CAL;
    state.cal.active=true;
    state.cal.p1=null; state.cal.p2=null; state.cal.pxPerMeter=null;
    calWarn.textContent='Klicke Punkt 1 im Plan.';
    calOk.textContent='';
    showToast('Kalibrierung: 2 Punkte klicken');
    setHud(`<b>Version ${VERSION}</b> • Kalibrieren: Punkt 1 klicken, dann Punkt 2.`);
    updateWizard();
  };
  btnCalReset.onclick = ()=>{
    state.cal={active:false,p1:null,p2:null,pxPerMeter:null};
    calMeters.value='';
    calOk.textContent=''; calWarn.textContent='';
    showToast('Kalibrierung zurückgesetzt');
    updateWizard();
  };

  btnSource.onclick = ()=>{ tool=tools.SOURCE; showToast('Wasserquelle: klicken'); };
  btnPool.onclick = ()=>{ tool=tools.POOL; showToast('Pool: klicken'); };

  btnPoolMove.onclick = ()=>{ tool=tools.MOVE_POOL; showToast('Pool verschieben: ziehen'); };

  btnBlockFree.onclick = ()=>{ tool=tools.BLOCK_FREE; state.drawingFree=null; showToast('Sperrzone Freihand'); };
  btnBlockPoly.onclick  = ()=>{ tool=tools.BLOCK_POLY; state.drawingPoly={pts:[], preview:null}; showToast('Sperrzone Polygon'); };
  btnBlocksClear.onclick= ()=>{ state.blocks=[]; showToast('Sperrzonen gelöscht'); updateWizard(); };

  btnPipe.onclick = ()=>{ tool=tools.PIPE; state.drawingPipe=null; showToast('Leitung: 1. Klick startet'); updateWizard(); };
  btnPipeCancel.onclick = ()=>{ state.drawingPipe=null; tool=tools.NONE; showToast('Leitung abgebrochen'); updateWizard(); };

  btnPlanClear.onclick = ()=>{
    state.source=null; state.pool=null; state.blocks=[]; state.pipes=[]; state.drawingPipe=null;
    tool=tools.NONE;
    showToast('Plan gelöscht');
    updateWizard();
  };
  btnResetAll.onclick = ()=>resetAll();

  // ===== calibration meter input =====
  calMeters.addEventListener('input', ()=>{
    if(!(state.cal.p1 && state.cal.p2)) return;
    const px=dist(state.cal.p1, state.cal.p2);
    const m=Number(calMeters.value||0);
    if(m>0){
      state.cal.pxPerMeter = px / m;
      state.cal.active=false;
      tool=tools.NONE;
      calOk.textContent='✓ Maßstab aktiv – Längen sind maßgetreu.';
      calWarn.textContent='';
      showToast('Maßstab gespeichert');
      updateWizard();
    }
  });

  // ===== zoom only with Ctrl =====
  canvas.addEventListener('wheel', (e)=>{
    if(!state.bg.img) return;
    if(!e.ctrlKey) return;
    e.preventDefault();

    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left, my=e.clientY-rect.top;
    const anchorWorld=screenToWorld({x:mx,y:my});

    const oldScale=state.bg.scale;
    const factor=(e.deltaY<0)?1.08:0.92;
    const newScale=Math.max(0.1, Math.min(10, oldScale*factor));

    const imgX=(anchorWorld.x - state.bg.x)/oldScale;
    const imgY=(anchorWorld.y - state.bg.y)/oldScale;

    state.bg.scale=newScale;
    state.bg.x=anchorWorld.x - imgX*newScale;
    state.bg.y=anchorWorld.y - imgY*newScale;
    draw();
  }, {passive:false});

  // ===== keyboard =====
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      if(tool===tools.MOVE_POOL){ tool=tools.NONE; showToast('Pool verschieben beendet'); updateWizard(); return; }
      if(state.drawingPipe){ state.drawingPipe=null; tool=tools.NONE; showToast('Leitung abgebrochen'); updateWizard(); return; }
      if(state.cal.active){ state.cal.active=false; state.cal.p1=null; state.cal.p2=null; tool=tools.NONE; showToast('Kalibrierung abgebrochen'); updateWizard(); return; }
      if(state.straighten.active){ state.straighten.active=false; state.straighten.p1=null; state.straighten.preview=null; tool=tools.NONE; showToast('Geradeziehen abgebrochen'); updateWizard(); return; }
      if(state.drawingPoly){ state.drawingPoly=null; showToast('Polygon abgebrochen'); draw(); return; }
    }
    if(e.key==='Enter'){
      if(tool===tools.BLOCK_POLY && state.drawingPoly){
        const pts=state.drawingPoly.pts;
        if(pts.length>=3){
          state.blocks.push({pts:[...pts]});
          showToast('Sperrzone gespeichert');
        } else showToast('Polygon: mind. 3 Punkte');
        state.drawingPoly={pts:[], preview:null};
        updateWizard();
      }
    }
  });

  // ===== draw helper =====
  function drawInWorld(fn){
    const c=bgCenter();
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(state.bg.rot);
    ctx.translate(-c.x, -c.y);
    fn();
    ctx.restore();
  }

  // ===== mouse/pointer =====
  canvas.addEventListener('mouseenter', ()=>state.pointerInCanvas=true);
  canvas.addEventListener('mouseleave', ()=>{
    state.pointerInCanvas=false;
    if(state.drawingPipe) state.drawingPipe.preview=null;
    if(state.drawingPoly) state.drawingPoly.preview=null;
    state.straighten.preview=null;
    state.bgDrag=null;
    state.draggingObj=null;
    draw();
  });

  canvas.addEventListener('mousedown', (e)=>{
    if(!state.bg.img) return;
    const ps=getPos(e);
    const pwRaw=screenToWorld(ps);
    const pw=snapPoint(pwRaw);

    // MOVE modes
    if(tool===tools.MOVE_ALL || tool===tools.MOVE_POOL){
      if((tool===tools.MOVE_ALL || tool===tools.MOVE_POOL) && state.pool && hitPool(pwRaw)){
        state.draggingObj={type:'pool', ox: pwRaw.x - state.pool.x, oy: pwRaw.y - state.pool.y};
        return;
      }
      if(tool===tools.MOVE_ALL && state.source && hitSource(pwRaw)){
        state.draggingObj={type:'source', ox: pwRaw.x - state.source.x, oy: pwRaw.y - state.source.y};
        return;
      }
      if(tool===tools.MOVE_ALL){
        state.bgDrag={ox:ps.x, oy:ps.y, startX:state.bg.x, startY:state.bg.y};
        return;
      }
    }

    // STRAIGHTEN
    if(tool===tools.STRAIGHT && state.straighten.active){
      if(!state.straighten.p1){
        state.straighten.p1=pw;
        showToast('Geradeziehen: Punkt 1');
        draw();
        return;
      } else {
        const p2=pw;
        const dx=p2.x-state.straighten.p1.x;
        const dy=p2.y-state.straighten.p1.y;
        const angle=Math.atan2(dy,dx);
        state.bg.rot = state.bg.rot - angle;
        showToast('Bild ausgerichtet ✅');
        // repeatable
        state.straighten.p1=null;
        state.straighten.preview=null;
        updateWizard();
        return;
      }
    }

    // CALIBRATION
    if(tool===tools.CAL && state.cal.active){
      if(!state.cal.p1){
        state.cal.p1=pw;
        calWarn.textContent='Punkt 1 gesetzt. Jetzt Punkt 2 klicken.';
        showToast('Kalibrierung: Punkt 1');
        draw();
        return;
      }
      if(!state.cal.p2){
        state.cal.p2=pw;
        calWarn.textContent='Jetzt Meter eingeben.';
        enable(calMeters,true);
        calMeters.focus();
        showToast('Kalibrierung: Punkt 2');
        updateWizard();
        return;
      }
    }

    // SOURCE
    if(tool===tools.SOURCE){
      state.source={x:pw.x,y:pw.y};
      tool=tools.NONE;
      showToast('Wasserquelle gesetzt');
      updateWizard();
      return;
    }

    // POOL place
    if(tool===tools.POOL){
      const shape=poolShape.value;
      const wM=Number(poolW.value||0);
      const hM=(shape==='round')?wM:Number(poolH.value||0);
      const wPx=snapValue(metersToPx(wM));
      const hPx=snapValue(metersToPx(hM));
      state.pool={shape,x:pw.x,y:pw.y,w:wPx,h:hPx};
      tool=tools.NONE;
      showToast('Pool gesetzt');
      updateWizard();
      return;
    }

    // BLOCK FREE start
    if(tool===tools.BLOCK_FREE){
      state.drawingFree={pts:[pw]};
      draw();
      return;
    }

    // BLOCK POLY add point
    if(tool===tools.BLOCK_POLY && state.drawingPoly){
      state.drawingPoly.pts.push(pw);
      draw();
      return;
    }

    // PIPE connected
    if(tool===tools.PIPE){
      if(!state.drawingPipe){
        state.drawingPipe={pts:[pw], preview:null};
        enable(btnPipeCancel,true);
        showToast('Leitung gestartet');
      } else {
        const pts=state.drawingPipe.pts;
        const last=pts[pts.length-1];
        if(last.x!==pw.x || last.y!==pw.y) pts.push(pw);
      }
      draw();
      return;
    }
  });

  canvas.addEventListener('mousemove', (e)=>{
    if(!state.bg.img) return;
    const ps=getPos(e);
    const pwRaw=screenToWorld(ps);
    const pw=snapPoint(pwRaw);

    if(state.draggingObj){
      if(state.draggingObj.type==='pool'){
        state.pool.x = snapValue(pwRaw.x - state.draggingObj.ox);
        state.pool.y = snapValue(pwRaw.y - state.draggingObj.oy);
        draw();
        return;
      }
      if(state.draggingObj.type==='source'){
        state.source.x = snapValue(pwRaw.x - state.draggingObj.ox);
        state.source.y = snapValue(pwRaw.y - state.draggingObj.oy);
        draw();
        return;
      }
    }
    if(state.bgDrag){
      state.bg.x = state.bgDrag.startX + (ps.x - state.bgDrag.ox);
      state.bg.y = state.bgDrag.startY + (ps.y - state.bgDrag.oy);
      draw();
      return;
    }

    if(tool===tools.STRAIGHT && state.straighten.active && state.straighten.p1){
      state.straighten.preview=pw;
      draw();
      return;
    }
    if(tool===tools.BLOCK_FREE && state.drawingFree){
      const pts=state.drawingFree.pts;
      const last=pts[pts.length-1];
      if(dist(last,pw) >= 6){
        pts.push(pw);
        draw();
      }
      return;
    }
    if(tool===tools.BLOCK_POLY && state.drawingPoly){
      state.drawingPoly.preview=pw;
      draw();
      return;
    }
    if(tool===tools.PIPE && state.drawingPipe){
      state.drawingPipe.preview=pw;
      draw();
      return;
    }
  });

  canvas.addEventListener('mouseup', ()=>{
    state.bgDrag=null;
    state.draggingObj=null;

    if(tool===tools.BLOCK_FREE && state.drawingFree){
      const pts=state.drawingFree.pts;
      if(pts.length>=10){
        const simplified=[pts[0]];
        for(let i=1;i<pts.length;i++){
          if(dist(simplified[simplified.length-1], pts[i])>=4) simplified.push(pts[i]);
        }
        state.blocks.push({pts:simplified});
        showToast('Sperrzone gespeichert');
      } else {
        showToast('Sperrzone zu klein (nochmal zeichnen)');
      }
      state.drawingFree=null;
      updateWizard();
    }
  });

  canvas.addEventListener('dblclick', ()=>{
    if(tool!==tools.PIPE) return;
    if(!state.drawingPipe) return;
    if(state.drawingPipe.pts.length>=2){
      state.pipes.push({pts:[...state.drawingPipe.pts]});
      showToast('Leitung gespeichert ✅');
    } else {
      showToast('Leitung: mind. 2 Punkte');
    }
    state.drawingPipe=null;
    tool=tools.NONE;
    enable(btnPipeCancel,false);
    updateWizard();
  });

  // ===== drawing =====
  function drawGrid(){
    if(gridMode.value!=='grid') return;
    const rect=canvas.getBoundingClientRect();
    const w=rect.width, h=rect.height;
    const g=state.grid;
    ctx.save();
    ctx.globalAlpha=0.18;
    ctx.strokeStyle='#2b3a4d';
    ctx.lineWidth=1;
    for(let x=0;x<w;x+=g){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=g){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }

  function drawBackground(){
    if(!state.bg.img) return;
    const img=state.bg.img;
    const w=img.width*state.bg.scale;
    const h=img.height*state.bg.scale;
    const c=bgCenter();
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.translate(c.x, c.y);
    ctx.rotate(state.bg.rot);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  }

  function drawBlocks(){
    if(!state.blocks.length && !state.drawingFree && !(state.drawingPoly && state.drawingPoly.pts.length)) return;
    drawInWorld(()=>{
      ctx.fillStyle='rgba(255,80,80,0.18)';
      ctx.strokeStyle='rgba(255,120,120,0.85)';
      ctx.lineWidth=2;

      const drawPoly = (pts, close=true)=>{
        if(pts.length<2) return;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        if(close) ctx.closePath();
        ctx.fill(); ctx.stroke();
      };

      for(const b of state.blocks){
        drawPoly(b.pts,true);
        ctx.fillStyle='rgba(255,170,170,0.92)';
        ctx.font='12px system-ui';
        ctx.fillText('SPERRZONE', b.pts[0].x+8, b.pts[0].y+16);
        ctx.fillStyle='rgba(255,80,80,0.18)';
      }

      if(state.drawingFree) drawPoly(state.drawingFree.pts,false);

      if(state.drawingPoly){
        const pts=[...state.drawingPoly.pts];
        if(state.drawingPoly.preview) pts.push(state.drawingPoly.preview);
        drawPoly(pts,false);
        ctx.fillStyle='rgba(255,170,170,0.92)';
        for(const p of state.drawingPoly.pts){ ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
      }
    });
  }

  function drawPool(){
    if(!state.pool) return;
    drawInWorld(()=>{
      const p=state.pool;
      ctx.fillStyle='#143a60';
      ctx.strokeStyle='#5aa7ff';
      ctx.lineWidth=2;

      if(p.shape==='rect'){
        roundedRectPath(p.x, p.y, p.w, p.h, 12);
        ctx.fill(); ctx.stroke();
      } else {
        const cx=p.x+p.w/2, cy=p.y+p.h/2;
        ctx.beginPath(); ctx.arc(cx, cy, p.w/2, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
      }

      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.font='12px system-ui';
      ctx.fillText('POOL / ZIEL', p.x+10, p.y+18);

      if(showMeasures.checked){
        const wM=pxToMeters(p.w);
        const hM=pxToMeters(p.h);
        let txt='';
        if(p.shape==='round'){
          const d=wM; const area=Math.PI*(d/2)*(d/2);
          txt=`Ø ${d.toFixed(2)} m • ${area.toFixed(2)} m²`;
        } else {
          const area=wM*hM;
          txt=`${wM.toFixed(2)}×${hM.toFixed(2)} m • ${area.toFixed(2)} m²`;
        }
        ctx.fillText(txt, p.x+10, p.y+34);
      }
    });
  }

  function drawSource(){
    if(!state.source) return;
    drawInWorld(()=>{
      ctx.fillStyle='#1f8cff';
      ctx.strokeStyle='#cbe4ff';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(state.source.x, state.source.y, 7, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.font='12px system-ui';
      ctx.fillText('WASSER', state.source.x+10, state.source.y+4);
    });
  }

  function drawPipes(){
    drawInWorld(()=>{
      ctx.strokeStyle='#7ee787';
      ctx.lineWidth=4;
      ctx.lineCap='round';
      ctx.lineJoin='round';

      const drawLine = (pts, previewPoint)=>{
        if(!pts.length) return;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        if(previewPoint) ctx.lineTo(previewPoint.x, previewPoint.y);
        ctx.stroke();

        ctx.fillStyle='#c9f7cf';
        for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); }
      };

      for(const p of state.pipes) drawLine(p.pts, null);

      if(state.drawingPipe){
        drawLine(state.drawingPipe.pts, state.drawingPipe.preview);
      }

      if(showMeasures.checked){
        ctx.fillStyle='rgba(255,255,255,.9)';
        ctx.font='12px system-ui';
        const labelSegs=(pts)=>{
          for(let i=0;i<pts.length-1;i++){
            const a=pts[i], b=pts[i+1];
            const mid={x:(a.x+b.x)/2, y:(a.y+b.y)/2};
            ctx.fillText(`${pxToMeters(dist(a,b)).toFixed(2)} m`, mid.x+6, mid.y-6);
          }
        };
        for(const p of state.pipes) labelSegs(p.pts);
      }
    });
  }

  function drawStraightPreview(){
    if(!(tool===tools.STRAIGHT && state.straighten.active && state.straighten.p1 && state.straighten.preview)) return;
    drawInWorld(()=>{
      ctx.strokeStyle='rgba(255,255,255,.85)';
      ctx.lineWidth=2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(state.straighten.p1.x, state.straighten.p1.y);
      ctx.lineTo(state.straighten.preview.x, state.straighten.preview.y);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  }

  function drawCalLine(){
    if(!state.cal.p1) return;
    drawInWorld(()=>{
      ctx.strokeStyle='rgba(255,255,255,.85)';
      ctx.lineWidth=2;
      ctx.setLineDash([6,6]);
      if(state.cal.p2){
        ctx.beginPath();
        ctx.moveTo(state.cal.p1.x, state.cal.p1.y);
        ctx.lineTo(state.cal.p2.x, state.cal.p2.y);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.arc(state.cal.p1.x, state.cal.p1.y, 6, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    });
  }

  function draw(){
    const rect=canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    drawBackground();
    drawGrid();
    drawBlocks();
    drawPool();
    drawSource();
    drawPipes();
    drawCalLine();
    drawStraightPreview();

    renderBOM();
  }

  // ===== initial enable =====
  function init(){
    updatePoolLabels();
    updatePoolLive();
    resize();
    updateWizard();
  }

  // enable / disable by bg presence
  function enableCoreByBg(){
    const hasBg = !!state.bg.img;
    enable(btnFit, hasBg);
    enable(btnMoveAll, hasBg);
    enable(btnRemove, hasBg);
    enable(btnStraight, hasBg);
    enable(btnStraightReset, hasBg);
    enable(btnCal, hasBg);
    enable(btnCalReset, hasBg);
    enable(btnSource, hasBg);
  }

  // hook wizard to core enabling
  const _uw = updateWizard;
  updateWizard = function(){
    enableCoreByBg();
    _uw();
  };

  init();
})();
</script>
</body>
</html>
